# Проверка SSH подписей коммитов и тегов в Git

Цель этой статьи – настроить в локальном Git-репозитории проверку SSH подписей коммитов и тегов. Дополнительно будет настроено подписание собственных коммитов и тегов с использование SSH ключа.

Предполагается, что за ведение списка допустимых подписантов (участников) репозитория отвечают один или несколько человек – доверенных лиц. Они формируют список публичных SSH ключей допустимых подписантов и осуществляют передачу готовой конфигурации всем остальным участникам.

## Основные задачи

-	Создать для работы с Git отдельное хранилище SSH ключей.
-	Сгенерировать собственный SSH ключ для Git.
-	Настроить в Git подписание собственных коммитов и тегов с использование SSH ключа.
-	Создать для каждого репозитория отдельный список публичных SSH ключей допустимых подписантов (участников репозитория). Это позволит управлять публичными SSH ключами участников каждого репозитория в отдельности.
-	Настроить проверку SSH подписей в Git.
-	Передать готовую конфигурацию остальным участникам.

## Соглашение об используемых каталогах

В качестве домашнего каталога SSH для Git выберем папку `~/.ssh/git`.

Для данных относящихся к конкретному репозиторию, используем отдельную папку `~/.ssh/git/<repo_name>`.

## Немного про ssh-agent

ssh-agent – программа, которая кэширует расшифрованные закрытые ключи и передает их клиентским программам SSH. Это позволяет вводить свою парольную фразу только один раз, при добавлении закрытого ключа в кэш агента, что может оказаться очень удобно при частом использовании SSH.

Агент обычно настроен на автоматический запуск при входе в систему. В большинстве случаев запускать его вручную не требуется.

### Краткий список команд для управления ssh-agent:

Добавить ключ в ssh-agent (в процессе необходимо ввести парольную фразу на файл закрытого ключа):

```
ssh-add /PATH/TO/keyfile
```

Удалить ключ из ssh-agent:

```
ssh-add -d /PATH/TO/keyfile
```

Удалить все ключи из ssh-agent:

```
ssh-add -D
```

Вывести список всех открытых ключей добавленных в ssh-agent:

```
ssh-add -L
```

Вывести отпечатки всех добавленных в ssh-agent ключей:

```
ssh-add -l
```

Защитить ssh-agent паролем:

```
ssh-add -x
```

Снять защиту паролем с ssh-agent:

```
ssh-add -X
```

## Генерация собственного SSH ключа

Генерируем пару SSH ключей (открытый и закрытый) для использования в Git, это будет собственный SSH ключ для подписания коммитов и тегов (в процессе генерации задаем и подтверждаем парольную фразу на файл закрытого ключа):

```
ssh-keygen -t ed25519 -C "User Name <email@example.com>" -f ~/.ssh/git/UserName_ed25519
```

В результате будут созданы два файла:

-	`~/.ssh/git/UserName_ed25519` – файл закрытого ключа.
-	`~/.ssh/git/UserName_ed25519.pub` – файл открытого (публичного) ключа.

Добавляем собственный SSH ключ в ssh-agent (в процессе необходимо ввести парольную фразу на файл закрытого ключа):

```
ssh-add ~/.ssh/git/UserName_ed25519.pub
```

Полученный публичный SSH ключ можно, например, добавить в свой профиль на GitLab или GitHub для корректной проверки подписей ваших коммитов и тегов в web-интерфейсе.

Кроме этого, может потребоваться отправить собственный публичный SSH ключ сопровождающему репозитория (или другому ответственному лицу) для добавления его в список публичных SSH ключей допустимых подписантов.

## Настройка собственной SSH подписи в Git

Для подписания коммитов и тегов будем использовать ранее сгенерированный SSH ключ. Все настройки Git произведем для локального репозитория, но их можно применить и глобально (`--global`) – для всех репозиториев на уровне пользователя.

Настраиваем Git на использование SSH для подписи коммитов и тегов:

```
git config --local gpg.format ssh
```

Указываем Git какой SSH ключ использовать для подписания коммитов и тегов. Так как собственный SSH ключ уже добавлен в ssh-agent, поэтому указываем файл открытого ключа. В этом случае, при подписании коммитов и тегов, Git будет автоматически получать соответствующий закрытый ключ от ssh-agent:

```
git config --local user.signingkey ~/.ssh/git/UserName_ed25519.pub
```

Настраиваем Git на автоматическое подписание коммитов и аннотированных тегов:

```
git config --local commit.gpgsign true
```

```
git config --local tag.forceSignAnnotated true
```

## Управление SSH ключами участников репозитория

Этот раздел предполагает, что Вы являетесь ответственным за ведение списка публичных SSH ключей допустимых подписантов (участников репозитория). Иначе обратитесь к сопровождающему репозитория за получением готовой конфигурации.

Для проверки SSH подписей коммитов и тегов всех участников репозитория, необходимо создать файл со списком публичных SSH ключей допустимых подписантов, каждая строка которого имеет следующий формат:

```
<principal>[,<principal>...] <options> <key type> <public key>
```

Все поля разделяются пробелами; пустые строки и строки начинающиеся с `#` игнорируются как комментарии; в конце строки, для наглядности, можно добавить имя участника репозитория или другую пометку.

Поле `principals` представляет собой список шаблонов, состоящий из одного или нескольких разделенных запятыми шаблонов идентификаторов личности USER@DOMAIN, которые принимаются для подписи. При проверке идентификатор, переданный в командной строке проверки, должен соответствовать одному из указанных шаблонов, чтобы соответствующий ключ считался допустимым для проверки.

> Обратите внимание, что при проверке подписи Git не передает адрес электронной почты автора или коммитера напрямую. Вместо этого Git:
> 
> - Сначала, с помощью команды `ssh-keygen -Y find-principals`, ищет в списке допустимых подписантов всех принципалов, связанных с открытым ключом подписи.
> - После чего, через опцию `-I`, передает первого найденного принципала команде проверки подписи `ssh-keygen -Y verify`.
> 
> В результате этого в поле `principals` не обязательно указывать тот же адрес электронной почты, который использует соответствующий участник репозитория при подписании своих коммитов и тегов.
>
> Это не задокументированное поведение и оно может измениться в будущем.

Поле `options` состоит из спецификаций опций (если они имеются), разделенных запятыми. Пробелы не допускаются, кроме тех, которые заключены в двойные кавычки. Поддерживаются следующие спецификации опций (обратите внимание, что имена опций не чувствительны к регистру):

- `cert-authority` – указывает, что данный ключ принят в качестве центра сертификации (ЦС) и что сертификаты, подписанные этим ЦС, могут быть приняты для проверки.
- `namespaces=namespace-list` – указывает список шаблонов пространств имен, которые принимаются для данного ключа. Если эта опция присутствует, то пространство имен подписи, встроенное в объект подписи и представленное в командной строке проверки, должно соответствовать указанному списку, прежде чем ключ будет считаться допустимым.
- `valid-after=timestamp` – указывает, что ключ действителен для использования в указанный момент времени или после него, который может быть датой или временем в форматах `YYYYMMDD[Z]` или `YYYYMMDDHHMM[SS][Z]`. Даты и время интерпретируются в текущем часовом поясе системы, если только они не дополнены символом `Z`, который заставляет их интерпретироваться в часовом поясе UTC.
- `valid-before=timestamp` – указывает, что ключ действителен для использования в указанный момент времени или до него.

Обратите внимание, что использование пространства имен помогает предотвратить межпротокольные атаки (cross-protocol attacks). Поэтому для всех ключей установим `namespaces="git"`.

Также, перед добавлением публичных SSH ключей в список допустимых подписантов, необходимо убедиться в их достоверности, например, сравнив отпечаток ключа (key fingerprint) с отпечатком, полученным от его владельца.

Получить SHA-256 отпечаток публичного SSH ключа:

```
ssh-keygen -lf /PATH/TO/public_key.pub
```

Получить MD5 отпечаток публичного SSH ключа:

```
ssh-keygen -E md5 -lf /PATH/TO/public_key.pub
```

Список допустимых подписантов можно сформировать как для отдельного репозитория, так и для группы, например личных репозиториев и репозиториев вашей компании.

Предположим, что для репозитория создается отдельный файл со списком публичных SSH ключей допустимых подписантов `~/.ssh/git/<repo_name>/allowed_signers`.

Добавляем в него собственный публичный SSH ключ из файла `~/.ssh/git/UserName_ed25519.pub`. В результате строка с собственным публичным SSH ключом будет иметь следующий вид:

```
email@example.com namespaces="git" ssh-ed25519 AAAAC3NzaC1lZDI1NTE5AAAAIMjgusOItM2E9gDvSWvybn3r/kjdO5aHikMnJLzs+V5b User Name
```

Аналогичным образом добавляем в файл `~/.ssh/git/<repo_name>/allowed_signers` публичные SSH ключи остальных допустимых подписантов.

## Настройка проверки SSH подписей в Git

Для проверки SSH подписей в локальном Git-репозитории используем подготовленный ранее файл со списком публичных SSH ключей допустимых подписантов `~/.ssh/git/<repo_name>/allowed_signers`.

Если Вы получили готовую конфигурацию – сохраните файл `allowed_signers` в каталоге `~/.ssh/git/<repo_name>`.

Настраиваем Git на использование списка допустимых подписантов:

```
git config --local gpg.ssh.allowedSignersFile ~/.ssh/git/<repo_name>/allowed_signers
```

На этом настройка проверки SSH подписей в локальном Git-репозитории закончена. Теперь Git выдаст результаты проверки SSH подписи согласно сформированному списку допустимых подписантов везде, где это будет запрошено.

## Передача готовой конфигурации

Готовая конфигурация расположена в каталоге `~/.ssh/git/<repo_name>` и состоит из одного файла:

```
allowed_signers
```

Сопровождающий репозитория может передать этот файл остальным участникам для проверки SSH подписей коммитов и тегов в их локальных репозиториях.

Участники репозитория, получившие готовую конфигурацию, должны настроить у себя проверку SSH подписей, как это описано в разделе "[Настройка проверки SSH подписей в Git](#%D0%BD%D0%B0%D1%81%D1%82%D1%80%D0%BE%D0%B9%D0%BA%D0%B0-%D0%BF%D1%80%D0%BE%D0%B2%D0%B5%D1%80%D0%BA%D0%B8-ssh-%D0%BF%D0%BE%D0%B4%D0%BF%D0%B8%D1%81%D0%B5%D0%B9-%D0%B2-git)".

